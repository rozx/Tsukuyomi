name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      # write permission is required to create a github release
      contents: write
      # write permission is required for autolabeler
      # otherwise, read permission is required at least
      pull-requests: write
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      release_created: ${{ steps.set_final_outputs.outputs.release_created }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Extract version from branch name
        id: extract_version
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          # Try to get branch name from associated PR
          BRANCH_NAME=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls --jq '.[0].head.ref' 2>/dev/null || echo "")
          
          # If no PR found, try to extract from current ref (in case of direct push)
          if [ -z "$BRANCH_NAME" ] || [ "$BRANCH_NAME" == "null" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          
          echo "Source branch: $BRANCH_NAME"
          
          # Extract version from branch name (support patterns like: release/0.5.15, v0.5.15, 0.5.15-release, etc.)
          VERSION=$(echo "$BRANCH_NAME" | grep -oE '[v]?[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          
          if [ -z "$VERSION" ]; then
            echo "No version found in branch name: $BRANCH_NAME"
            echo "version_found=false" >> $GITHUB_OUTPUT
          else
            # Remove 'v' prefix if present
            VERSION=$(echo "$VERSION" | sed 's/^v//')
            echo "Extracted version from branch: $VERSION"
            echo "version_found=true" >> $GITHUB_OUTPUT
            echo "expected_version=$VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Check and update version
        id: check_version
        if: steps.extract_version.outputs.version_found == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          CURRENT_VERSION=$(jq -r .version package.json)
          EXPECTED_VERSION="${{ steps.extract_version.outputs.expected_version }}"
          
          echo "Current version in package.json: $CURRENT_VERSION"
          echo "Expected version from branch: $EXPECTED_VERSION"
          
          # Normalize versions to ensure they have 3 parts (major.minor.patch)
          normalize_version() {
            local ver=$1
            # Remove any pre-release or build metadata
            ver=$(echo "$ver" | sed 's/-.*//' | sed 's/+.*//')
            # Split by dots
            IFS='.' read -r -a parts <<< "$ver"
            # Ensure we have at least 2 parts (major.minor)
            if [ ${#parts[@]} -lt 2 ]; then
              echo "Error: Invalid version format: $ver" >&2
              return 1
            fi
            # Add patch version if missing
            if [ ${#parts[@]} -eq 2 ]; then
              ver="${ver}.0"
            fi
            echo "$ver"
          }
          
          CURRENT_VERSION_NORM=$(normalize_version "$CURRENT_VERSION")
          EXPECTED_VERSION_NORM=$(normalize_version "$EXPECTED_VERSION")
          
          if [ -z "$CURRENT_VERSION_NORM" ] || [ -z "$EXPECTED_VERSION_NORM" ]; then
            echo "❌ Failed to normalize versions"
            exit 1
          fi
          
          echo "Normalized current version: $CURRENT_VERSION_NORM"
          echo "Normalized expected version: $EXPECTED_VERSION_NORM"
          
          # Function to compare semantic versions
          # Returns: 0 if v1 == v2, 1 if v1 > v2, 2 if v1 < v2
          compare_versions() {
            local v1=$1
            local v2=$2
            
            # Split versions into major.minor.patch
            IFS='.' read -r -a v1_parts <<< "$v1"
            IFS='.' read -r -a v2_parts <<< "$v2"
            
            # Ensure both versions have 3 parts
            while [ ${#v1_parts[@]} -lt 3 ]; do
              v1_parts+=("0")
            done
            while [ ${#v2_parts[@]} -lt 3 ]; do
              v2_parts+=("0")
            done
            
            # Compare major version
            if [ "${v1_parts[0]}" -gt "${v2_parts[0]}" ]; then
              return 1
            elif [ "${v1_parts[0]}" -lt "${v2_parts[0]}" ]; then
              return 2
            fi
            
            # Compare minor version
            if [ "${v1_parts[1]}" -gt "${v2_parts[1]}" ]; then
              return 1
            elif [ "${v1_parts[1]}" -lt "${v2_parts[1]}" ]; then
              return 2
            fi
            
            # Compare patch version
            if [ "${v1_parts[2]}" -gt "${v2_parts[2]}" ]; then
              return 1
            elif [ "${v1_parts[2]}" -lt "${v2_parts[2]}" ]; then
              return 2
            fi
            
            return 0
          }
          
          # Compare versions using normalized versions
          compare_versions "$CURRENT_VERSION_NORM" "$EXPECTED_VERSION_NORM"
          COMPARE_RESULT=$?
          
          if [ $COMPARE_RESULT -eq 0 ]; then
            # Versions are equal
            echo "✅ Version matches: $CURRENT_VERSION"
            echo "version_updated=false" >> $GITHUB_OUTPUT
            echo "final_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          elif [ $COMPARE_RESULT -eq 1 ]; then
            # Current version is greater than expected version
            echo "ℹ️ Local version ($CURRENT_VERSION) is greater than branch version ($EXPECTED_VERSION)"
            echo "Keeping local version: $CURRENT_VERSION"
            echo "version_updated=false" >> $GITHUB_OUTPUT
            echo "final_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          else
            # Expected version is greater than current version
            echo "⚠️ Version mismatch detected!"
            echo "Updating version from $CURRENT_VERSION to $EXPECTED_VERSION"
            
            # Update version using bump script
            echo "Running: bun run bump \"$EXPECTED_VERSION\""
            bun run bump "$EXPECTED_VERSION"
            
            if [ $? -ne 0 ]; then
              echo "❌ Failed to run bump script"
              exit 1
            fi
            
            # Verify the update
            NEW_VERSION=$(jq -r .version package.json)
            NEW_VERSION_NORM=$(normalize_version "$NEW_VERSION")
            EXPECTED_NORM=$(normalize_version "$EXPECTED_VERSION")
            
            if [ "$NEW_VERSION_NORM" == "$EXPECTED_NORM" ]; then
              echo "✅ Version updated successfully to $NEW_VERSION"
              echo "version_updated=true" >> $GITHUB_OUTPUT
              echo "final_version=$NEW_VERSION" >> $GITHUB_OUTPUT
            else
              echo "❌ Failed to update version."
              echo "   Expected: $EXPECTED_VERSION (normalized: $EXPECTED_NORM)"
              echo "   Got: $NEW_VERSION (normalized: $NEW_VERSION_NORM)"
              exit 1
            fi
          fi

      - name: Commit version update
        if: steps.check_version.outputs.version_updated == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
          
          git add package.json src/constants/version.ts
          git commit -m "chore: bump version to ${{ steps.check_version.outputs.final_version }}" || exit 0
          git push origin HEAD:${{ github.ref_name }} || echo "No changes to commit or already up to date"

      - name: Check for release label
        id: check_label
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          # Get associated PRs for this commit
          LABELS=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls --jq '.[].labels[].name' 2>/dev/null || echo "")
          echo "Labels found from commit PRs: $LABELS"
          if echo "$LABELS" | grep -q "release"; then
            echo "has_release_label=true" >> $GITHUB_OUTPUT
          else
            echo "has_release_label=false" >> $GITHUB_OUTPUT
          fi

      - name: Get version from package.json
        id: get_version
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          # Use the version from check_version step if available, otherwise read from package.json
          if [ "${{ steps.check_version.outputs.final_version }}" != "" ]; then
            VERSION="${{ steps.check_version.outputs.final_version }}"
            echo "Using version from version check step: $VERSION"
          else
            VERSION=$(jq -r .version package.json)
            echo "Using version from package.json: $VERSION"
          fi
          echo "version=v$VERSION" >> $GITHUB_OUTPUT

      - name: Check if tag exists
        id: check_tag
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          git fetch --tags
          if git rev-parse "${{ steps.get_version.outputs.version }}" >/dev/null 2>&1; then
            echo "Tag ${{ steps.get_version.outputs.version }} already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Tag
        if: steps.check_label.outputs.has_release_label == 'true' && steps.check_tag.outputs.exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag ${{ steps.get_version.outputs.version }}
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
          git push origin ${{ steps.get_version.outputs.version }}

      - name: Check and prepare release notes
        id: prepare_release_notes
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          RELEASE_NOTES_FILE="docs/ReleaseNotes/RELEASE_NOTES_${VERSION}.md"
          
          echo "Checking for release notes file: $RELEASE_NOTES_FILE"
          
          if [ -f "$RELEASE_NOTES_FILE" ]; then
            echo "✅ Release notes file found: $RELEASE_NOTES_FILE"
            echo "has_release_notes=true" >> $GITHUB_OUTPUT
            echo "release_notes_path=$RELEASE_NOTES_FILE" >> $GITHUB_OUTPUT
          else
            echo "ℹ️ No release notes file found at $RELEASE_NOTES_FILE, will use auto-generated notes"
            echo "has_release_notes=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Release (with release notes file)
        id: create_release
        if: steps.check_label.outputs.has_release_label == 'true' && steps.prepare_release_notes.outputs.has_release_notes == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          body_path: ${{ steps.prepare_release_notes.outputs.release_notes_path }}
          draft: false
          prerelease: false
          make_latest: true
        env:
          # 优先使用 PAT（如果存在），否则使用默认的 GITHUB_TOKEN
          # 对于私有仓库，PAT 通常更可靠
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Create Release (with auto-generated notes)
        id: create_release_auto
        if: steps.check_label.outputs.has_release_label == 'true' && steps.prepare_release_notes.outputs.has_release_notes != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          generate_release_notes: true
          draft: false
          prerelease: false
          make_latest: true
        env:
          # 优先使用 PAT（如果存在），否则使用默认的 GITHUB_TOKEN
          # 对于私有仓库，PAT 通常更可靠
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Set Final Outputs
        id: set_final_outputs
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          # Check if either release creation step succeeded
          if [ "${{ steps.create_release.outcome }}" == "success" ] || [ "${{ steps.create_release_auto.outcome }}" == "success" ]; then
            echo "release_created=true" >> $GITHUB_OUTPUT
          else
            echo "release_created=false" >> $GITHUB_OUTPUT
          fi

  build:
    needs: create-release
    if: needs.create-release.outputs.release_created == 'true'
    runs-on: ${{ matrix.os }}
    permissions:
      # write permission is required to upload release assets
      contents: write
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build for macOS
        if: matrix.os == 'macos-latest'
        run: bun run build:electron
        env:
          NODE_ENV: production
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          # macOS 代码签名配置（如果已配置证书）
          # CSC_LINK: ${{ secrets.MACOS_CERTIFICATE }}
          # CSC_KEY_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          # APPLE_ID: ${{ secrets.APPLE_ID }}
          # APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}

      - name: Build for Windows
        if: matrix.os == 'windows-latest'
        run: bun run build:electron
        env:
          NODE_ENV: production
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          # Windows 代码签名配置（如果已配置证书）
          # CSC_LINK: ${{ secrets.WINDOWS_CERTIFICATE }}
          # CSC_KEY_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      - name: Build for Linux
        if: matrix.os == 'ubuntu-latest'
        run: bun run build:electron
        env:
          NODE_ENV: production
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Package Mac App Bundle
        if: matrix.os == 'macos-latest'
        run: |
          # 查找 .app bundle（可能在 mac-arm64、mac-x64 或 Packaged/mac-* 目录中）
          echo "Searching for .app bundle in dist/electron..."
          APP_PATH=$(find dist/electron -name "*.app" -type d | head -1)
          
          if [ -z "$APP_PATH" ]; then
            echo "Error: No .app bundle found in dist/electron"
            echo "Listing dist/electron structure for debugging:"
            find dist/electron -type d -maxdepth 3 | head -20
            exit 1
          fi
          
          echo "Found .app bundle at: $APP_PATH"
          APP_DIR=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          cd "$APP_DIR"
          ZIP_NAME="${APP_NAME%.app}-mac.zip"
          echo "Creating zip: $ZIP_NAME"
          zip -r "$ZIP_NAME" "$APP_NAME"
          echo "Zip file created at: $(pwd)/$ZIP_NAME"

      - name: Find and prepare Mac zip for upload
        if: matrix.os == 'macos-latest'
        id: macos_prepare
        run: |
          # Extract version (remove 'v' prefix for filename)
          VERSION="${{ needs.create-release.outputs.version }}"
          VERSION_NO_PREFIX="${VERSION#v}"
          
          # 查找创建的 zip 文件并移动到固定位置
          ZIP_PATH=$(find dist/electron -name "*-mac.zip" -type f | head -1)
          if [ -z "$ZIP_PATH" ]; then
            echo "Error: No zip file found"
            exit 1
          fi
          echo "Found zip at: $ZIP_PATH"
          # 确保 dist/electron 目录存在，并将 zip 复制到带版本号的名称
          mkdir -p dist/electron
          VERSIONED_FILENAME="luna-ai-translator-${VERSION_NO_PREFIX}-mac.zip"
          cp "$ZIP_PATH" "dist/electron/${VERSIONED_FILENAME}"
          echo "Zip file prepared at: dist/electron/${VERSIONED_FILENAME}"
          echo "versioned_filename=${VERSIONED_FILENAME}" >> $GITHUB_OUTPUT

      - name: Upload Release Assets (MacOS)
        if: matrix.os == 'macos-latest'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          # Mac 生成 .app bundle（单文件可执行程序），压缩为 .zip 以便分发
          files: dist/electron/${{ steps.macos_prepare.outputs.versioned_filename }}
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Find and prepare Windows exe for upload
        if: matrix.os == 'windows-latest'
        shell: pwsh
        id: windows_prepare
        run: |
          # Extract version (remove 'v' prefix for filename)
          $version = "${{ needs.create-release.outputs.version }}"
          $versionNoPrefix = $version -replace '^v', ''
          
          # 查找 .exe 文件（可能在 Packaged 或其他目录中）
          Write-Host "Searching for .exe file in dist/electron..."
          $exePath = Get-ChildItem -Path dist/electron -Filter "*.exe" -Recurse -File | Select-Object -First 1
          
          if (-not $exePath) {
            Write-Host "Error: No .exe file found in dist/electron"
            Write-Host "Listing dist/electron structure for debugging:"
            Get-ChildItem -Path dist/electron -Recurse -Directory | Select-Object -First 20 | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          
          Write-Host "Found .exe at: $($exePath.FullName)"
          # 将 exe 复制到带版本号的名称
          $versionedFilename = "luna-ai-translator-${versionNoPrefix}-windows.exe"
          Copy-Item -Path $exePath.FullName -Destination "dist/electron/$versionedFilename" -Force
          Write-Host "Exe file prepared at: dist/electron/$versionedFilename"
          echo "versioned_filename=$versionedFilename" >> $env:GITHUB_OUTPUT

      - name: Upload Release Assets (Windows)
        if: matrix.os == 'windows-latest'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          # Windows 生成 portable .exe（单文件可执行程序）
          files: dist/electron/${{ steps.windows_prepare.outputs.versioned_filename }}
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Find and prepare Linux AppImage for upload
        if: matrix.os == 'ubuntu-latest'
        id: linux_prepare
        run: |
          # Extract version (remove 'v' prefix for filename)
          VERSION="${{ needs.create-release.outputs.version }}"
          VERSION_NO_PREFIX="${VERSION#v}"
          
          # 查找 .AppImage 文件（可能在 Packaged 或其他目录中）
          echo "Searching for .AppImage file in dist/electron..."
          APPIMAGE_PATH=$(find dist/electron -name "*.AppImage" -type f | head -1)
          
          if [ -z "$APPIMAGE_PATH" ]; then
            echo "Error: No .AppImage file found in dist/electron"
            echo "Listing dist/electron structure for debugging:"
            find dist/electron -type d -maxdepth 3 | head -20
            exit 1
          fi
          
          echo "Found .AppImage at: $APPIMAGE_PATH"
          # 将 AppImage 复制到带版本号的名称
          VERSIONED_FILENAME="luna-ai-translator-${VERSION_NO_PREFIX}-linux.AppImage"
          cp "$APPIMAGE_PATH" "dist/electron/${VERSIONED_FILENAME}"
          echo "AppImage file prepared at: dist/electron/${VERSIONED_FILENAME}"
          echo "versioned_filename=${VERSIONED_FILENAME}" >> $GITHUB_OUTPUT

      - name: Upload Release Assets (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/electron/${{ steps.linux_prepare.outputs.versioned_filename }}
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
