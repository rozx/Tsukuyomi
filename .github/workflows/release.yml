name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      # write permission is required to create a github release
      contents: write
      # write permission is required for autolabeler
      # otherwise, read permission is required at least
      pull-requests: write
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      release_created: ${{ steps.set_final_outputs.outputs.release_created }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Extract version from branch name
        id: extract_version
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          # Try to get branch name from associated PR
          BRANCH_NAME=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls --jq '.[0].head.ref' 2>/dev/null || echo "")
          
          # If no PR found, try to extract from current ref (in case of direct push)
          if [ -z "$BRANCH_NAME" ] || [ "$BRANCH_NAME" == "null" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          
          echo "Source branch: $BRANCH_NAME"
          
          # Extract version from branch name (support patterns like: release/0.5.15, v0.5.15, 0.5.15-release, etc.)
          VERSION=$(echo "$BRANCH_NAME" | grep -oE '[v]?[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          
          if [ -z "$VERSION" ]; then
            echo "No version found in branch name: $BRANCH_NAME"
            echo "version_found=false" >> $GITHUB_OUTPUT
          else
            # Remove 'v' prefix if present
            VERSION=$(echo "$VERSION" | sed 's/^v//')
            echo "Extracted version from branch: $VERSION"
            echo "version_found=true" >> $GITHUB_OUTPUT
            echo "expected_version=$VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Check and update version
        id: check_version
        if: steps.extract_version.outputs.version_found == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          CURRENT_VERSION=$(jq -r .version package.json)
          EXPECTED_VERSION="${{ steps.extract_version.outputs.expected_version }}"
          
          echo "Current version in package.json: $CURRENT_VERSION"
          echo "Expected version from branch: $EXPECTED_VERSION"
          
          if [ "$CURRENT_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "⚠️ Version mismatch detected!"
            echo "Updating version from $CURRENT_VERSION to $EXPECTED_VERSION"
            
            # Update version using bump script
            bun run bump "$EXPECTED_VERSION"
            
            # Verify the update
            NEW_VERSION=$(jq -r .version package.json)
            if [ "$NEW_VERSION" == "$EXPECTED_VERSION" ]; then
              echo "✅ Version updated successfully to $NEW_VERSION"
              echo "version_updated=true" >> $GITHUB_OUTPUT
              echo "final_version=$NEW_VERSION" >> $GITHUB_OUTPUT
            else
              echo "❌ Failed to update version. New version is: $NEW_VERSION"
              exit 1
            fi
          else
            echo "✅ Version matches: $CURRENT_VERSION"
            echo "version_updated=false" >> $GITHUB_OUTPUT
            echo "final_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Commit version update
        if: steps.check_version.outputs.version_updated == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
          
          git add package.json src/constants/version.ts
          git commit -m "chore: bump version to ${{ steps.check_version.outputs.final_version }}" || exit 0
          git push origin HEAD:${{ github.ref_name }} || echo "No changes to commit or already up to date"

      - name: Check for release label
        id: check_label
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          # Get associated PRs for this commit
          LABELS=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls --jq '.[].labels[].name' 2>/dev/null || echo "")
          echo "Labels found from commit PRs: $LABELS"
          if echo "$LABELS" | grep -q "release"; then
            echo "has_release_label=true" >> $GITHUB_OUTPUT
          else
            echo "has_release_label=false" >> $GITHUB_OUTPUT
          fi

      - name: Get version from package.json
        id: get_version
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          # Use the version from check_version step if available, otherwise read from package.json
          if [ "${{ steps.check_version.outputs.final_version }}" != "" ]; then
            VERSION="${{ steps.check_version.outputs.final_version }}"
            echo "Using version from version check step: $VERSION"
          else
            VERSION=$(jq -r .version package.json)
            echo "Using version from package.json: $VERSION"
          fi
          echo "version=v$VERSION" >> $GITHUB_OUTPUT

      - name: Check if tag exists
        id: check_tag
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          git fetch --tags
          if git rev-parse "${{ steps.get_version.outputs.version }}" >/dev/null 2>&1; then
            echo "Tag ${{ steps.get_version.outputs.version }} already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Tag
        if: steps.check_label.outputs.has_release_label == 'true' && steps.check_tag.outputs.exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag ${{ steps.get_version.outputs.version }}
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
          git push origin ${{ steps.get_version.outputs.version }}

      - name: Create Release
        id: create_release
        if: steps.check_label.outputs.has_release_label == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          generate_release_notes: true
          draft: false
          prerelease: false
          make_latest: true
        env:
          # 优先使用 PAT（如果存在），否则使用默认的 GITHUB_TOKEN
          # 对于私有仓库，PAT 通常更可靠
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Set Final Outputs
        id: set_final_outputs
        if: steps.check_label.outputs.has_release_label == 'true'
        run: |
          if [ "${{ steps.create_release.outcome }}" == "success" ]; then
            echo "release_created=true" >> $GITHUB_OUTPUT
          else
            echo "release_created=false" >> $GITHUB_OUTPUT
          fi

  build:
    needs: create-release
    if: needs.create-release.outputs.release_created == 'true'
    runs-on: ${{ matrix.os }}
    permissions:
      # write permission is required to upload release assets
      contents: write
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build for macOS
        if: matrix.os == 'macos-latest'
        run: bun run build:electron
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Build for Windows
        if: matrix.os == 'windows-latest'
        run: bun run build:electron
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Build for Linux
        if: matrix.os == 'ubuntu-latest'
        run: bun run build:electron
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Package Mac App Bundle
        if: matrix.os == 'macos-latest'
        run: |
          # 查找 .app bundle（可能在 mac-arm64、mac-x64 或 Packaged/mac-* 目录中）
          echo "Searching for .app bundle in dist/electron..."
          APP_PATH=$(find dist/electron -name "*.app" -type d | head -1)
          
          if [ -z "$APP_PATH" ]; then
            echo "Error: No .app bundle found in dist/electron"
            echo "Listing dist/electron structure for debugging:"
            find dist/electron -type d -maxdepth 3 | head -20
            exit 1
          fi
          
          echo "Found .app bundle at: $APP_PATH"
          APP_DIR=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          cd "$APP_DIR"
          ZIP_NAME="${APP_NAME%.app}-mac.zip"
          echo "Creating zip: $ZIP_NAME"
          zip -r "$ZIP_NAME" "$APP_NAME"
          echo "Zip file created at: $(pwd)/$ZIP_NAME"

      - name: Find and prepare Mac zip for upload
        if: matrix.os == 'macos-latest'
        run: |
          # 查找创建的 zip 文件并移动到固定位置
          ZIP_PATH=$(find dist/electron -name "*-mac.zip" -type f | head -1)
          if [ -z "$ZIP_PATH" ]; then
            echo "Error: No zip file found"
            exit 1
          fi
          echo "Found zip at: $ZIP_PATH"
          # 确保 dist/electron 目录存在，并将 zip 复制到那里
          mkdir -p dist/electron
          cp "$ZIP_PATH" dist/electron/mac-release.zip
          echo "Zip file prepared at: dist/electron/mac-release.zip"

      - name: Upload Release Assets (MacOS)
        if: matrix.os == 'macos-latest'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          # Mac 生成 .app bundle（单文件可执行程序），压缩为 .zip 以便分发
          files: dist/electron/mac-release.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Find and prepare Windows exe for upload
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          # 查找 .exe 文件（可能在 Packaged 或其他目录中）
          Write-Host "Searching for .exe file in dist/electron..."
          $exePath = Get-ChildItem -Path dist/electron -Filter "*.exe" -Recurse -File | Select-Object -First 1
          
          if (-not $exePath) {
            Write-Host "Error: No .exe file found in dist/electron"
            Write-Host "Listing dist/electron structure for debugging:"
            Get-ChildItem -Path dist/electron -Recurse -Directory | Select-Object -First 20 | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          
          Write-Host "Found .exe at: $($exePath.FullName)"
          # 确保 dist/electron 目录存在，并将 exe 复制到那里
          New-Item -ItemType Directory -Force -Path dist/electron | Out-Null
          Copy-Item -Path $exePath.FullName -Destination dist/electron/windows-release.exe -Force
          Write-Host "Exe file prepared at: dist/electron/windows-release.exe"

      - name: Upload Release Assets (Windows)
        if: matrix.os == 'windows-latest'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          # Windows 生成 portable .exe（单文件可执行程序）
          files: dist/electron/windows-release.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Find and prepare Linux AppImage for upload
        if: matrix.os == 'ubuntu-latest'
        run: |
          # 查找 .AppImage 文件（可能在 Packaged 或其他目录中）
          echo "Searching for .AppImage file in dist/electron..."
          APPIMAGE_PATH=$(find dist/electron -name "*.AppImage" -type f | head -1)
          
          if [ -z "$APPIMAGE_PATH" ]; then
            echo "Error: No .AppImage file found in dist/electron"
            echo "Listing dist/electron structure for debugging:"
            find dist/electron -type d -maxdepth 3 | head -20
            exit 1
          fi
          
          echo "Found .AppImage at: $APPIMAGE_PATH"
          # 将 AppImage 复制到 dist/electron 目录
          cp "$APPIMAGE_PATH" dist/electron/linux-release.AppImage
          echo "AppImage file prepared at: dist/electron/linux-release.AppImage"

      - name: Upload Release Assets (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/electron/linux-release.AppImage
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
